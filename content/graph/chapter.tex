\chapter{Graph}

\section{Fundamentals}
	\kactlimport{BellmanFord.h}
	\kactlimport{FloydWarshall.h}
	\kactlimport{TopoSort.h}

\section{Network flow}
	\kactlimport{PushRelabel.h}
	\kactlimport{MinCostMaxFlow.h}
	\kactlimport{EdmondsKarp.h}
	\kactlimport{Dinic.h}
	\kactlimport{MinCut.h}
	\kactlimport{GlobalMinCut.h}
	\kactlimport{GomoryHu.h}

\section{Matching}
	\kactlimport{hopcroftKarp.h}
	\kactlimport{DFSMatching.h}
	\kactlimport{MinimumVertexCover.h}
	\kactlimport{WeightedMatching.h}
	\kactlimport{GeneralMatching.h}

\section{DFS algorithms}
	\kactlimport{SCC.h}
	\kactlimport{BiconnectedComponents.h}
	\kactlimport{CentroidDecomposition.h}
	\kactlimport{2sat.h}
	\kactlimport{EulerWalk.h}
	\kactlimport{VirtualTree.h}

\section{Coloring}
	\kactlimport{EdgeColoring.h}

\section{Heuristics}
	\kactlimport{MaximalCliques.h}
	\kactlimport{MaximumClique.h}
	\kactlimport{MaximumIndependentSet.h}

\section{Trees}
	\kactlimport{BinaryLifting.h}
	\kactlimport{LCA.h}
	\kactlimport{CompressTree.h}
	\kactlimport{HLD.h}
	\kactlimport{LinkCutTree.h}
	\kactlimport{DirectedMST.h}

\section{Math}
	\subsection{Number of Spanning Trees}
		% I.e. matrix-tree theorem.
		% Source: https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem
		% Test: stress-tests/graph/matrix-tree.cpp
		Create an $N\times N$ matrix \texttt{mat}, and for each edge $a \rightarrow b \in G$, do
		\texttt{mat[a][b]--, mat[b][b]++} (and \texttt{mat[b][a]--, mat[a][a]++} if $G$ is undirected).
		Remove the $i$th row and column and take the determinant; this yields the number of directed spanning trees rooted at $i$
		(if $G$ is undirected, remove any row/column).

	\subsection{Erdős–Gallai theorem}
		% Source: https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Gallai_theorem
		% Test: stress-tests/graph/erdos-gallai.cpp
		A simple graph with node degrees $d_1 \ge \dots \ge d_n$ exists iff $d_1 + \dots + d_n$ is even and for every $k = 1\dots n$,
		\[ \sum _{i=1}^{k}d_{i}\leq k(k-1)+\sum _{i=k+1}^{n}\min(d_{i},k). \]

	\subsection{V\'ertices que pertenecen a todos los maximum matching bipartitos}
		Crea un grafo auxiliar. Dirige las aristas no emparejadas de $L \rightarrow R$ y las emparejadas de $R \rightarrow L$.  
		Calcula $Z_L$, v\'ertices que alcanzables desde v\'ertices libres en L. 
		De forma an\'aloga calcula $Z_R$, el conjunto buscado es $(L - Z_L) \cup (R - Z_R)$.

	\subsection{L-R Flow}
		Flow with demands. Nuevos v\'ertices $S'$ y $T'$. Reemplaza las aristas $(u,v,l,r)$ por tres aristas: $(u,v,r-l)$, $(S',v,l)$ y $(u,T',l)$. 
		Una arista m\'as $(T,S,\infty)$. 
		Corre un primer maxflow de $S'$ a $T'$, si es menor a la suma de todos los $l$, el flujo buscado no existe. 
		Corre un segundo maxflow de $S$ a $T$, este es el flujo m\'aximo buscado originalmente.  
	\subsection{Cow Game}
		Resuelve un problema de maximizaci\'on. Si se tienen desigualdades $d_v \leq d_u + c$, puedes construir un grafo con aristas $u \rightarrow v$ con peso $c$. 
		Maximiza $a_t - a_s$ usando BellmanFord. Si no existe soluci\'on, existe un ciclo negativo o $s$ no alcanza a $t$.  